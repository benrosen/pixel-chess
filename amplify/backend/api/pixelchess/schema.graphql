input AppendMoveTextInput {
  move: Move!
}

# TODO connection input, mutations, subscriptions, etc.
# TODO configure createConnection resolver
# TODO configure deleteConnection resolver
# TODO update Game when connection is created/deleted
type Connection
  @aws_iam
  @auth(
    rules: [
      { allow: public, provider: iam, operations: [create] }
      { allow: owner, operations: [delete] }
    ]
  )
  @model(mutations: null, subscriptions: null) {
  id: ID!
  gameId: ID!
}

type Game
  @aws_iam
  @auth(
    rules: [
      { allow: private, provider: iam, operations: [update] }
      { allow: public, provider: iam, operations: [create] }
    ]
  )
  @model(mutations: null, subscriptions: null)
  @versioned {
  id: ID!
  black: String
  moveText: String
  status: Status!
  white: String
}

# TODO connection input, mutations, subscriptions, etc.
# TODO configure createMove resolver
# TODO configure deleteMove resolver
# TODO update Game when connection is created/deleted
type Move
  @aws_iam
  @auth(rules: [{ allow: public, provider: iam, operations: [create] }])
  @model(mutations: null, subscriptions: null) {
  id: ID!
  gameId: ID!
  moveText: String!
}

# TODO create resolvers for all of these mutations
# TODO remove vanilla updateGame mutation resolvers and references in CustomResources.json
type Mutation {
  createGame: Game @aws_iam
  appendMoveText(input: AppendMoveTextInput): Game @aws_iam
  setBlackPlayer(input: SetBlackPlayerInput): Game @aws_iam
  setWhitePlayer(input: SetWhitePlayerInput): Game @aws_iam
  updateStatus(input: UpdateStatusInput): Game @aws_iam
}

input SetBlackPlayerInput {
  gameId: ID!
}

input SetWhitePlayerInput {
  gameId: ID!
}

enum Status {
  PENDING
  UNDERWAY
  DRAW
  BLACK_WON
  WHITE_WON
}

type Subscription {
  onUpdateGame(id: ID!): Game
    @aws_subscribe(
      mutations: [
        "appendMoveText"
        "setBlackPlayer"
        "setWhitePlayer"
        "updateStatus"
      ]
    )
}

input UpdateStatusInput {
  gameId: ID!
  status: Status!
}
